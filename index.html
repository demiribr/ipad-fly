<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D viewer</title>

    <!-- 3rd party libraries (from bower) -->
    <link href="lib/font-awesome/css/font-awesome.css" rel="stylesheet"></link>
    <script src="lib/tweenjs/src/Tween.js"></script>

    <!-- Our code -->
    <link href="css/view3d.css" rel="stylesheet">

  </head>
  <body ng-app="viewer">

    <!-- Informatics prototype badge -->
    <informatics-badge></informatics-badge>

    <div ng-controller="MainController">

      <!-- Stats modal -->
      <div ng-include="includes/stats.html"></div>

      <!-- HUD Controls -->
      <div class="hud">
        <molab-location-search griddims="grid_dims" geobounds="geo_bounds" movefunc="moveCamera"></molab-location-search>
        <div class="btn" title="Reset view" href="#" style="height: auto; position: absolute; top:60px; left: 20px; color: white; font-size: 14pt" ng-click="moveCamera({x: 130, y: 2000, z: 2000});">
          <i class="fa fa-refresh fa-3x"></i>
        </div>
        <div id="forward" class="btn" href="#" style="display: none;">
          <i class="fa fa-arrow-circle-o-up fa-5x"></i><br>forward
        </div>
        <div id="backward" class="btn" href="#" style="display: none;">
          <i class="fa fa-arrow-circle-o-down fa-5x"></i><br>backward
        </div>
        <div id="socket-connect" class="btn" href="#" style="display: none;">
          <i class="fa fa-laptop fa-5x"></i><br>connect
        </div>
        <div id="socket-id">
          Disconnected
        </div>
      </div>

      <div class="content">
        <div id="webgl"></div>
      </div>

    </div><!-- MainController -->

    <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&signed_in=true&libraries=places"></script>

    <!-- 3rd party libraries (from bower) -->
    <script src="lib/angularjs/angular.js"></script>
    <script src="lib/informatics-badge-directive/informatics-badge.js"></script>
    <script src="lib/three.js/three.min.js"> </script>
    <script src="lib/jquery/jquery.js"></script>
    <script src="https://cdn.socket.io/socket.io-1.3.5.js"></script>

    <!-- Custom/imported libraries -->
    <script src="js/utils/xmlToJSON.js"> </script>
    <script src="js/utils/latlon.js"></script>
    <script src="js/utils/stats.min.js"></script>

    <!-- Camera controllers -->
    <script src="js/controls/TrackballControls.js"></script>
    <script src="js/controls/DeviceOrientationController.js"></script>

    <!-- Shaders -->
    <script src="js/shaders/fragment_shader0.js" id="fragment_shader0" type="x-shader/x-fragment"></script>
    <script src="js/shaders/fragment_shader1.js" id="fragment_shader1" type="x-shader/x-fragment"></script>
    <script src="js/shaders/vertexShader0.js" id="vertexShader0" type="x-shader/x-vertex"></script>
    <script src="js/shaders/vertexShader1.js" id="vertexShader1" type="x-shader/x-vertex"></script>

    <script id="vertex_shader" type="x-shader/x-vertex">

    attribute vec4 tangent;
    attribute float amplitude;
    attribute float displacement;

    varying vec3 vTangent;
		varying vec3 vBinormal;
		varying vec3 vNormal;
		varying vec2 vUv;


		varying vec3 vPointLightVector;
		varying vec3 vViewPosition;

    uniform vec3 uPointLightPos;

    #ifdef VERTEX_TEXTURES

      uniform sampler2D tDisplacement;
      uniform float uDisplacementScale;
      uniform float uDisplacementBias;
      uniform float uDisplacementPostScale;

    #endif


		void main() {

      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      vViewPosition = -mvPosition.xyz; // ah HA

      vNormal = normalize( normalMatrix * normal );

      //tangent and binormal vectors
      vTangent = normalize( normalMatrix * tangent.xyz );

      vBinormal = cross( vNormal, vTangent ) * tangent.w;
      vBinormal = normalize( vBinormal );

      vUv = uv;



      // point light
      vec4 lPosition      = viewMatrix * vec4( uPointLightPos, 1.0 );
      vPointLightVector   = normalize( lPosition.xyz - mvPosition.xyz );

      #ifdef VERTEX_TEXTURES
          vec3 dv                 = texture2D( tDisplacement, vUv ).xyz;

          // minus otherwise displacement moves in negative direction
          float df                = -(uDisplacementScale * dv.x + uDisplacementBias);

          vec4 displacedPosition  = vec4( vNormal.xyz * df * uDisplacementPostScale/100.0, 0.0 ) + mvPosition;

          gl_Position             = projectionMatrix * displacedPosition;
      #else
        gl_Position = projectionMatrix * mvPosition;
      #endif
		}

  </script>




    <!-- ----- FRAGMENT SHADER ----- -->

    <script id="fragment_shader" type="x-shader/x-fragment">

    #extension GL_OES_standard_derivatives : enable

    uniform vec3 uPointLightPos;

    uniform vec3 uAmbientLightColor;
    uniform vec3 uPointLightColor;

    uniform vec3 uAmbientColor;
    uniform vec3 uDiffuseColor;
    uniform vec3 uSpecularColor;
    uniform float uShininess; //

    uniform sampler2D tDiffuse;
    uniform sampler2D tDisplacement;
    uniform sampler2D tNormal;
    uniform sampler2D tSpec;  //
    uniform sampler2D tOcc; //

    uniform float tDiffuseOpacity;

    uniform float uNormalScale; //

    varying vec3 vTangent;
    varying vec3 vBinormal;
    varying vec3 vNormal;
    varying vec2 vUv;

    varying vec3 vPointLightVector;
    varying vec3 vViewPosition;

    uniform float uDisplacementPostScale;

    uniform float bumpScale;

  // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen
  //	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html

  // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

  vec2 dHdxy_fwd() {
    vec2 dSTdx = dFdx( vUv );
    vec2 dSTdy = dFdy( vUv );

    float hll = bumpScale * texture2D( tDisplacement, vUv ).x;
    float dBx = bumpScale * texture2D( tDisplacement, vUv + dSTdx ).x - hll;
    float dBy = bumpScale * texture2D( tDisplacement, vUv + dSTdy ).x - hll;

    return vec2( dBx, dBy );

  }

  vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {

    vec3 vSigmaX = dFdx( surf_pos );
    vec3 vSigmaY = dFdy( surf_pos );
    vec3 vN = surf_norm;		// normalized

    vec3 R1 = cross( vSigmaY, vN );
    vec3 R2 = cross( vN, vSigmaX );

    float fDet = dot( vSigmaX, R1 );

    vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
    return normalize( abs( fDet ) * surf_norm - vGrad );

  }


    void main() {

      vec4 diffuseTex     = texture2D( tDiffuse, vUv ) * tDiffuseOpacity;
      diffuseTex.a        = tDiffuseOpacity;
      // vec3 specTex        = texture2D( tSpec, vUv ).xyz;
      // vec3 occTex         = texture2D( tOcc, vUv ).xyz;
      vec3 normalTex      = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;

      mat3 tsb            = mat3( vTangent, vBinormal, vNormal );
      vec3 finalNormal    = tsb * normalTex.rgb;

      vec3 normal         = normalize( finalNormal );
      vec3 normal2         = normalize( finalNormal );

      vec3 viewPosition   = normalize( vViewPosition );

      normal = perturbNormalArb( -vViewPosition, normal * vec3(100.0/(uDisplacementPostScale+1.0)), dHdxy_fwd() );

      normal = normalize(normal);
      // point light

      vec4 pointDiffuse           = vec4( 0.0, 0.0, 0.0, 0.0 );
      vec4 pointSpecular          = vec4( 0.0, 0.0, 0.0, 0.0 ); //

      vec3 pointVector            = normalize( vPointLightVector );
      float dotProduct = dot( normal, pointVector );

      float pointDiffuseWeight = max( dotProduct, 0.0 );

      vec3 pointHalfVector        = normalize( vPointLightVector + viewPosition );


      // specular

      float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );
      float pointSpecularWeight   = 0.0;  //
      pointSpecularWeight += max( pow( pointDotNormalHalf, uShininess ), 0.0 );
      pointSpecular += vec4( uSpecularColor, 1.0 ) * vec4( uPointLightColor, 1.0 ) * pointSpecularWeight * pointDiffuseWeight;

      if ( pointDotNormalHalf >= 0.0 )    pointSpecularWeight = pow( pointDotNormalHalf, uShininess );  // no spectex
      pointDiffuse                  += vec4( uDiffuseColor, 1.0 ) * vec4( uPointLightColor, 1.0 ) * pointDiffuseWeight;

      // all lights contribution summation

      vec4 totalLight             = vec4( uAmbientLightColor * uAmbientColor , 1.0 ); // orig
      totalLight                 += vec4( uPointLightColor, 1.0 ) * ( pointDiffuse + pointSpecular );

      // with texture
      gl_FragColor = vec4( diffuseTex.xyz + totalLight.xyz, 1.0 );

      // without texture
      // gl_FragColor = vec4( totalLight.xyz, 1.0 );

    }
  </script>

    <!-- Our code -->
    <script src="js/socket.js"></script>
    <script src="js/view3d.js"></script>
    <script src="js/viewer.controller.js"></script>
    <script src="js/location_search/molabCoordService.js"></script>
    <script src="js/controls/HUD.js"></script>
    <script src="js/location_search/molabLocationSearch.js"></script>



  </body>
</html>
